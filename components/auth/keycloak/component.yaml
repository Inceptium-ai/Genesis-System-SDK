# =============================================================================
# Keycloak Identity & Access Management Component
# =============================================================================
# Enterprise-grade OIDC identity provider with OAuth 2.0, SSO, and RBAC
# Validated in: UC1 Resume Optimizer experiment
# =============================================================================

name: keycloak
version: 24.0.x
category: identity
validated: 2024-12-13

description: |
  Enterprise-grade OIDC identity provider with OAuth 2.0, SSO, and RBAC.
  Provides authentication for all Genesis blueprints with support for 
  social login, MFA, and user federation.

# =============================================================================
# PORTS & NETWORKING
# =============================================================================
ports:
  default: 8080
  alternate: 8084  # Recommended to avoid conflicts
  admin_console: /admin
  health: /health/ready
  conflicts_note: |
    Port 8080 commonly conflicts with:
    - Tomcat defaults
    - Jenkins defaults  
    - Spring Boot defaults
    - Other Java web servers
    
    RECOMMENDATION: Use port 8084 for local development:
    ```yaml
    ports:
      - "8084:8080"
    ```
    
    Then update frontend KEYCLOAK_URL to http://localhost:8084

# =============================================================================
# ENVIRONMENT VARIABLES
# =============================================================================
environment:
  required:
    - name: KEYCLOAK_ADMIN
      description: Admin username for Keycloak console
      default: admin
      
    - name: KEYCLOAK_ADMIN_PASSWORD
      description: Admin password (change immediately!)
      sensitive: true
      
    - name: KC_DB_URL
      description: JDBC database connection URL
      format: "jdbc:postgresql://host:5432/keycloak"
      
    - name: KC_DB_USERNAME
      description: Database username
      
    - name: KC_DB_PASSWORD
      description: Database password
      sensitive: true
      
    - name: KC_HEALTH_ENABLED
      description: Enable health endpoints (REQUIRED for healthchecks)
      default: "true"
      required_note: |
        MUST be set to "true" for health endpoints to work.
        Without this, /health/ready returns 404 in Keycloak 22+.
      
  optional:
    - name: KC_HOSTNAME
      description: External hostname
      default: localhost
      
    - name: KC_PROXY
      description: Proxy mode (none, edge, reencrypt, passthrough)
      default: edge
      
    - name: KC_HTTP_ENABLED
      description: Enable HTTP (required for dev)
      default: "true"

# =============================================================================
# DOCKER
# =============================================================================
docker:
  image: quay.io/keycloak/keycloak:24.0
  port: 8080
  
  compose_snippet: |
    keycloak:
      image: quay.io/keycloak/keycloak:24.0
      container_name: ${APP_NAME}-keycloak
      command: start-dev --import-realm
      environment:
        KEYCLOAK_ADMIN: ${KEYCLOAK_ADMIN:-admin}
        KEYCLOAK_ADMIN_PASSWORD: ${KEYCLOAK_ADMIN_PASSWORD}
        KC_DB: postgres
        KC_DB_URL: jdbc:postgresql://postgres:5432/keycloak
        KC_DB_USERNAME: ${POSTGRES_USER}
        KC_DB_PASSWORD: ${POSTGRES_PASSWORD}
        KC_HEALTH_ENABLED: "true"
        KC_HTTP_ENABLED: "true"
        KC_HOSTNAME_STRICT: "false"
        KC_PROXY: edge
      volumes:
        - ./config/keycloak/realm.json:/opt/keycloak/data/import/realm.json:ro
      ports:
        - "8080:8080"
      depends_on:
        postgres:
          condition: service_healthy
      healthcheck:
        test: ["CMD-SHELL", "exec 3<>/dev/tcp/127.0.0.1/8080"]
        interval: 30s
        timeout: 10s
        retries: 10
        start_period: 60s

# =============================================================================
# OIDC ENDPOINTS
# =============================================================================
endpoints:
  well_known: /realms/{realm}/.well-known/openid-configuration
  authorization: /realms/{realm}/protocol/openid-connect/auth
  token: /realms/{realm}/protocol/openid-connect/token
  userinfo: /realms/{realm}/protocol/openid-connect/userinfo
  jwks: /realms/{realm}/protocol/openid-connect/certs
  logout: /realms/{realm}/protocol/openid-connect/logout

# =============================================================================
# AWS DEPLOYMENT
# =============================================================================
aws:
  option_1:
    name: ECS Fargate
    description: Run Keycloak as container
    instance: 1 vCPU, 2GB memory
    
  option_2:
    name: Amazon Cognito
    description: Managed alternative (can import Keycloak realms)
    
  database: RDS PostgreSQL for production

# =============================================================================
# USER INFO SCHEMA (Standard Dict)
# =============================================================================
user_info_schema:
  description: |
    Standard schema for user information dict returned by get_current_user().
    All routes and services MUST use these key names to ensure consistency
    across generated code. This prevents Bug #7 (keycloak_id vs sub mismatch).
    
  fields:
    keycloak_id:
      jwt_claim: "sub"
      type: string
      required: true
      description: "Unique user identifier from Keycloak"
      usage: "current_user['keycloak_id']"
      
    email:
      jwt_claim: "email"
      type: string
      required: true
      description: "User's email address"
      usage: "current_user['email']"
      
    username:
      jwt_claim: "preferred_username"
      type: string
      required: true
      fallback: "email prefix before @"
      description: "Username for display"
      usage: "current_user['username']"
      
    first_name:
      jwt_claim: "given_name"
      type: string
      required: false
      description: "User's first name"
      
    last_name:
      jwt_claim: "family_name"
      type: string
      required: false
      description: "User's last name"
      
    name:
      jwt_claim: "name"
      type: string
      required: false
      description: "User's full name"
      
    email_verified:
      jwt_claim: "email_verified"
      type: boolean
      required: false
      default: false
      description: "Whether email has been verified"
      
    roles:
      jwt_claim: "realm_access.roles"
      type: "list[string]"
      required: false
      default: []
      description: "List of realm roles assigned to user"
      
  implementation: |
    ```python
    def extract_user_info(self, claims: Dict) -> Dict:
        """
        Extract standardized user info from JWT claims.
        
        IMPORTANT: All routes/services must use these key names:
        - keycloak_id (not 'sub')
        - email (direct mapping)
        - username (not 'preferred_username')
        - roles (extracted from realm_access.roles)
        """
        return {
            "keycloak_id": claims.get("sub"),
            "email": claims.get("email"),
            "username": claims.get("preferred_username") or claims.get("email", "").split("@")[0],
            "first_name": claims.get("given_name"),
            "last_name": claims.get("family_name"),
            "name": claims.get("name"),
            "email_verified": claims.get("email_verified", False),
            "roles": claims.get("realm_access", {}).get("roles", []),
        }
    ```
    
  why_not_raw_claims: |
    We use descriptive names instead of raw JWT claims because:
    1. Self-documenting: keycloak_id is clearer than sub
    2. Provider-agnostic: Code is more readable if we switch identity providers
    3. Prevents confusion: sub might be confused with "subscription"
    4. Consistency: All generated code uses the same key names

# =============================================================================
# INTEGRATION PATTERNS (Complete Guide)
# =============================================================================
patterns:
  # ---------------------------------------------------------------------------
  # STEP 1: React Frontend with keycloak-js
  # ---------------------------------------------------------------------------
  react_setup: |
    # Install keycloak-js
    npm install keycloak-js
    
    # Create src/keycloak.ts:
    import Keycloak from 'keycloak-js';
    
    const keycloak = new Keycloak({
      url: 'http://localhost:8081',      // Keycloak server
      realm: 'resumax',                  // Your realm name
      clientId: 'resumax-web',           // Client ID from realm config
    });
    
    export default keycloak;
    
  react_provider: |
    # Create src/AuthProvider.tsx:
    import { createContext, useContext, useEffect, useState, ReactNode } from 'react';
    import keycloak from './keycloak';
    
    interface AuthContextType {
      isAuthenticated: boolean;
      token: string | null;
      user: any;
      login: () => void;
      logout: () => void;
      register: () => void;
    }
    
    const AuthContext = createContext<AuthContextType | null>(null);
    
    export function AuthProvider({ children }: { children: ReactNode }) {
      const [isAuthenticated, setIsAuthenticated] = useState(false);
      const [token, setToken] = useState<string | null>(null);
      const [user, setUser] = useState<any>(null);
    
      useEffect(() => {
        keycloak.init({ onLoad: 'check-sso' }).then((authenticated) => {
          setIsAuthenticated(authenticated);
          if (authenticated) {
            setToken(keycloak.token ?? null);
            setUser(keycloak.tokenParsed);
          }
        });
    
        // Token refresh
        keycloak.onTokenExpired = () => {
          keycloak.updateToken(30).then((refreshed) => {
            if (refreshed) setToken(keycloak.token ?? null);
          });
        };
      }, []);
    
      const login = () => keycloak.login();
      const logout = () => keycloak.logout();
      const register = () => keycloak.register();
    
      return (
        <AuthContext.Provider value={{ isAuthenticated, token, user, login, logout, register }}>
          {children}
        </AuthContext.Provider>
      );
    }
    
    export const useAuth = () => {
      const context = useContext(AuthContext);
      if (!context) throw new Error('useAuth must be used within AuthProvider');
      return context;
    };
    
  react_usage: |
    # Wrap app with AuthProvider in main.tsx:
    import { AuthProvider } from './AuthProvider';
    
    ReactDOM.createRoot(document.getElementById('root')!).render(
      <AuthProvider>
        <App />
      </AuthProvider>
    );
    
    # Use in components:
    import { useAuth } from './AuthProvider';
    
    function Header() {
      const { isAuthenticated, user, login, logout, register } = useAuth();
    
      return (
        <header>
          {isAuthenticated ? (
            <>
              <span>Welcome, {user?.preferred_username}</span>
              <button onClick={logout}>Logout</button>
            </>
          ) : (
            <>
              <button onClick={login}>Login</button>
              <button onClick={register}>Register</button>
            </>
          )}
        </header>
      );
    }
    
  # ---------------------------------------------------------------------------
  # STEP 2: FastAPI Backend JWT Validation
  # ---------------------------------------------------------------------------
  fastapi_setup: |
    # Add to requirements.txt:
    pyjwt[crypto]>=2.8.0
    httpx>=0.25.0
    
    # Create auth.py:
    import os
    from functools import lru_cache
    from fastapi import Depends, HTTPException, status
    from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
    import jwt
    import httpx
    
    KEYCLOAK_URL = os.getenv("KEYCLOAK_URL", "http://keycloak:8080")
    KEYCLOAK_REALM = os.getenv("KEYCLOAK_REALM", "resumax")
    CLIENT_ID = os.getenv("KEYCLOAK_CLIENT_ID", "resumax-web")
    
    security = HTTPBearer()
    
    @lru_cache()
    def get_jwks():
        """Fetch and cache Keycloak public keys"""
        url = f"{KEYCLOAK_URL}/realms/{KEYCLOAK_REALM}/protocol/openid-connect/certs"
        response = httpx.get(url)
        return response.json()
    
    def validate_token(token: str) -> dict:
        """Validate JWT and return decoded payload"""
        try:
            jwks = get_jwks()
            # Get the key id from token header
            unverified = jwt.get_unverified_header(token)
            kid = unverified.get("kid")
            
            # Find matching key
            key = None
            for k in jwks.get("keys", []):
                if k.get("kid") == kid:
                    key = jwt.algorithms.RSAAlgorithm.from_jwk(k)
                    break
            
            if not key:
                raise HTTPException(401, "Invalid token key")
            
            # Decode with verification
            payload = jwt.decode(
                token,
                key,
                algorithms=["RS256"],
                audience=CLIENT_ID,
                options={"verify_aud": True}
            )
            return payload
        except jwt.ExpiredSignatureError:
            raise HTTPException(401, "Token expired")
        except jwt.InvalidTokenError as e:
            raise HTTPException(401, f"Invalid token: {e}")
    
    async def get_current_user(
        credentials: HTTPAuthorizationCredentials = Depends(security)
    ) -> dict:
        """Dependency to get current authenticated user"""
        return validate_token(credentials.credentials)
    
    async def require_role(role: str):
        """Dependency factory to require specific role"""
        async def check_role(user: dict = Depends(get_current_user)):
            roles = user.get("realm_access", {}).get("roles", [])
            if role not in roles:
                raise HTTPException(403, f"Role '{role}' required")
            return user
        return check_role
    
  fastapi_usage: |
    # Use in endpoints:
    from auth import get_current_user
    
    @app.post("/api/roast")
    async def roast_resume(
        request: RoastRequest,
        user: dict = Depends(get_current_user)  # Requires auth
    ):
        user_id = user.get("sub")  # Keycloak user ID
        email = user.get("email")
        # ... process request
        return {"user": user_id, "result": "..."}
    
    # Require specific role
    @app.get("/api/admin/users")
    async def list_users(
        admin: dict = Depends(require_role("admin"))
    ):
        # Only admins can access
        return {"users": [...]}
    
  # ---------------------------------------------------------------------------
  # STEP 3: API Calls with Token
  # ---------------------------------------------------------------------------
  react_api_calls: |
    # Create api client with auth:
    import { useAuth } from './AuthProvider';
    
    function useApi() {
      const { token } = useAuth();
      
      const api = async (endpoint: string, options: RequestInit = {}) => {
        const res = await fetch(`http://localhost:8000${endpoint}`, {
          ...options,
          headers: {
            ...options.headers,
            'Authorization': `Bearer ${token}`,
            'Content-Type': 'application/json',
          },
        });
        
        if (res.status === 401) {
          // Token expired, trigger re-login
          keycloak.login();
        }
        
        return res.json();
      };
      
      return api;
    }
    
    // Usage in components:
    const api = useApi();
    const result = await api('/api/roast', {
      method: 'POST',
      body: JSON.stringify({ resumeText, jobDescription }),
    });

# =============================================================================
# REALM TEMPLATE
# =============================================================================
template:
  realm_json: |
    {
      "realm": "my-realm",
      "enabled": true,
      "sslRequired": "external",
      "registrationAllowed": true,
      "loginWithEmailAllowed": true,
      "duplicateEmailsAllowed": false,
      "resetPasswordAllowed": true,
      "editUsernameAllowed": false,
      "bruteForceProtected": true,
      "clients": [
        {
          "clientId": "my-webapp",
          "enabled": true,
          "publicClient": true,
          "directAccessGrantsEnabled": true,
          "redirectUris": ["http://localhost:3000/*"],
          "webOrigins": ["http://localhost:3000"],
          "defaultClientScopes": ["web-origins", "profile", "email"]
        }
      ],
      "users": [
        {
          "username": "testuser",
          "enabled": true,
          "email": "test@example.com",
          "credentials": [
            {"type": "password", "value": "testpass123!", "temporary": false}
          ]
        }
      ]
    }

# =============================================================================
# TROUBLESHOOTING
# =============================================================================
troubleshooting:
  - symptom: Container exits immediately
    cause: Database not ready or invalid credentials
    solution: Ensure postgres healthcheck passes before Keycloak starts
    
  - symptom: Realm import fails
    cause: Invalid JSON or duplicate realm
    solution: Validate JSON syntax, delete existing realm
    
  - symptom: CORS errors from frontend
    cause: Web origins not configured
    solution: Add frontend URL to client's Web Origins in admin console

# =============================================================================
# DOCKER NETWORKING GOTCHAS (CRITICAL)
# =============================================================================
docker_gotchas:
  description: |
    When running Keycloak in Docker with a frontend on localhost and a 
    backend in another container, there are several networking issues 
    that cause silent auth failures. These were discovered during 
    Genesis deep-cline-v2 testing (December 2025).
    
  critical_issues:
    - id: jwt_issuer_mismatch
      symptom: "401 Unauthorized on all API calls even when user is logged in"
      cause: |
        Token issuer URL mismatch between frontend and backend:
        - Frontend gets token from: http://localhost:8080
        - Token issuer field contains: http://localhost:8080/realms/myrealm
        - Backend validates token against: http://keycloak:8080/realms/myrealm
        - Backend rejects token because issuers don't match!
      solution: |
        Add KC_HOSTNAME and KC_HOSTNAME_PORT to Keycloak container:
        ```yaml
        keycloak:
          environment:
            KC_HOSTNAME: localhost      # Forces token issuer to use localhost
            KC_HOSTNAME_PORT: 8080      # Ensures correct port in issuer URL
        ```
      alternative: |
        If you can't set KC_HOSTNAME, disable issuer verification in backend:
        ```python
        # Python JWT decode
        claims = jwt.decode(
            token,
            signing_key,
            algorithms=["RS256"],
            options={
                "verify_signature": True,   # Keep - validates token is real
                "verify_exp": True,         # Keep - validates not expired
                "verify_iss": False,        # DISABLE - Docker network issue
            }
        )
        ```
        
    - id: backend_cannot_use_localhost
      symptom: "Backend cannot fetch JWKS from localhost:8080"
      cause: |
        Inside a Docker container, 'localhost' refers to the container itself,
        not the host machine. The backend cannot reach Keycloak via localhost.
      solution: |
        Backend must use Docker DNS name (e.g., 'keycloak:8080') for JWKS fetch,
        but this creates the issuer mismatch above. Use KC_HOSTNAME fix.
        
    - id: config_consistency
      symptom: "Invalid client credentials or 'client not found' errors"  
      cause: |
        When different tasks/scripts create config files independently,
        they may use different values for the same setting:
        - init-keycloak.sh creates: client_id = "app-frontend"
        - .env contains: KEYCLOAK_CLIENT_ID = "app-client"  
        - keycloak.ts uses: clientId = "app-web"
      solution: |
        1. Define single source of truth (e.g., .env file)
        2. All scripts/code must read from that source
        3. Validate consistency with pre-deploy check:
        ```bash
        grep -r "CLIENT_ID" . --include="*.sh" --include="*.env" --include="*.ts"
        ```
        
    - id: user_not_synced_to_db
      symptom: "404 Not Found when authenticated user calls API"
      cause: |
        Keycloak manages users, but app has local database. User exists in
        Keycloak but not in app's users table. Service tries to find user
        by keycloak_id, fails, returns 404.
      solution: |
        Implement get_or_create pattern (auto-sync on first API call):
        ```python
        async def get_or_create_user(self, user_info: dict) -> User:
            keycloak_id = user_info.get('keycloak_id')
            
            # Try to find existing user
            user = await db.execute(
                select(User).where(User.keycloak_id == keycloak_id)
            ).scalar_one_or_none()
            
            if not user:
                # Auto-create on first API call
                user = User(
                    keycloak_id=keycloak_id,
                    email=user_info.get('email'),
                    username=user_info.get('username')
                )
                db.add(user)
                await db.commit()
            
            return user
        ```

  recommended_docker_compose: |
    ```yaml
    keycloak:
      image: quay.io/keycloak/keycloak:24.0
      command: start-dev --import-realm
      environment:
        # Admin credentials
        KEYCLOAK_ADMIN: ${KEYCLOAK_ADMIN:-admin}
        KEYCLOAK_ADMIN_PASSWORD: ${KEYCLOAK_ADMIN_PASSWORD}
        # Database
        KC_DB: postgres
        KC_DB_URL: jdbc:postgresql://postgres:5432/keycloak
        KC_DB_USERNAME: ${POSTGRES_USER}
        KC_DB_PASSWORD: ${POSTGRES_PASSWORD}
        # CRITICAL: Hostname settings for Docker dev
        KC_HOSTNAME: localhost            # <-- Required for issuer match
        KC_HOSTNAME_PORT: 8080            # <-- Required for port match
        KC_HOSTNAME_STRICT: "false"       # <-- Allow dev without HTTPS
        KC_HTTP_ENABLED: "true"           # <-- Required for dev
        KC_HEALTH_ENABLED: "true"
      ports:
        - "8080:8080"
      depends_on:
        postgres:
          condition: service_healthy
    ```

# =============================================================================
# NEXT.JS INTEGRATION PATTERNS
# =============================================================================
nextjs_integration:
  description: |
    Next.js App Router requires special handling for keycloak-js due to:
    - Server-side rendering (SSR) where window is undefined
    - Hot Module Replacement (HMR) causing double initialization
    - The need for PKCE flow with public clients
    
  required_files:
    - path: public/silent-check-sso.html
      description: Required for silent SSO check
      content: |
        <!doctype html>
        <html>
        <head><title>Silent Check SSO</title></head>
        <body>
          <script>parent.postMessage(location.href, location.origin);</script>
        </body>
        </html>
        
    - path: src/lib/keycloak.ts
      description: Keycloak client with Next.js-safe patterns
      see_component: nextjs-frontend (patterns.keycloak_client)
      
  keycloak_realm_config:
    description: Required client settings for Next.js SPA
    settings:
      - name: Client authentication
        value: "OFF (public client)"
        reason: SPAs cannot securely store client secrets
        
      - name: Standard flow
        value: "ON"
        reason: Required for OAuth authorization code flow
        
      - name: Direct access grants
        value: "OFF"
        reason: Not needed for SPA, reduces attack surface
        
      - name: Valid redirect URIs
        value: "http://localhost:3000/*"
        reason: Must include frontend URL with wildcard
        
      - name: Web origins
        value: "http://localhost:3000"
        reason: Required for CORS - no wildcard allowed
        
      - name: Proof Key for Code Exchange (PKCE)
        value: "Enabled"
        reason: Security best practice for public clients
        
  gotchas:
    - issue: keycloak-js initializes twice in Next.js dev mode
      cause: Hot Module Replacement re-executes component code
      solution: |
        Use a singleton pattern with initPromise:
        ```typescript
        let initPromise: Promise<boolean> | null = null;
        
        export async function initKeycloak() {
          if (initPromise) {
            return initPromise;  // Reuse in-progress init
          }
          initPromise = keycloak.init({...});
          return initPromise;
        }
        ```
        
    - issue: Keycloak code errors on server (window is undefined)
      cause: Next.js SSR runs component code on server
      solution: |
        1. Add 'use client' directive to components using Keycloak
        2. Guard initialization:
        ```typescript
        if (typeof window === 'undefined') {
          throw new Error('Keycloak can only be used in browser');
        }
        ```
        3. Use useEffect (runs only on client)
        
    - issue: Silent SSO check fails with 404
      cause: Missing public/silent-check-sso.html
      solution: Create the file with parent.postMessage script
      
    - issue: CORS error on token endpoint
      cause: Frontend URL not in client's Web Origins
      solution: |
        Keycloak Admin Console > Clients > [your-client]:
        - Web Origins: http://localhost:3000
        - Valid Redirect URIs: http://localhost:3000/*
        
    - issue: Login redirects to wrong URL
      cause: redirectUri not set in login() call
      solution: |
        ```typescript
        await keycloak.login({
          redirectUri: `${window.location.origin}/dashboard`
        });
        ```
        
    - issue: Token refresh fails in background tabs
      cause: Browser throttles background JavaScript
      solution: Refresh token before each API call, not on timer

  environment_variables:
    frontend:
      - name: NEXT_PUBLIC_KEYCLOAK_URL
        example: "http://localhost:8084"
        note: Use NEXT_PUBLIC_ prefix for client-side access
        
      - name: NEXT_PUBLIC_KEYCLOAK_REALM
        example: "my-realm"
        
      - name: NEXT_PUBLIC_KEYCLOAK_CLIENT_ID
        example: "my-app"
        
  verification_checklist:
    - step: 1. Keycloak server accessible
      command: curl -sf http://localhost:8084/health/ready
      expected: '{"status":"UP"}'
      
    - step: 2. Realm exists
      command: curl -sf http://localhost:8084/realms/my-realm
      expected: Contains "realm":"my-realm"
      
    - step: 3. OIDC config available
      command: curl -sf http://localhost:8084/realms/my-realm/.well-known/openid-configuration
      expected: Contains "authorization_endpoint"
      
    - step: 4. Client exists
      command: |
        # Get admin token first, then:
        # GET /admin/realms/my-realm/clients?clientId=my-app
      expected: Returns client configuration
      
    - step: 5. Test token endpoint
      command: |
        curl -X POST http://localhost:8084/realms/my-realm/protocol/openid-connect/token \
          -d "grant_type=password" \
          -d "client_id=my-app" \
          -d "username=testuser" \
          -d "password=testpass123!"
      expected: Contains "access_token"
      
    - step: 6. Silent SSO file accessible
      command: curl -sf http://localhost:3000/silent-check-sso.html
      expected: Contains "postMessage"

# =============================================================================
# INIT SCRIPT REQUIREMENTS (V20 BUG FIX)
# =============================================================================
init_script_requirements:
  description: |
    The init-keycloak.sh script MUST configure the client with all required settings.
    Missing these causes 400 Bad Request on login/registration endpoints.
    
  discovered_in: V20 ResuMax experiment (December 2025)
  
  required_client_settings:
    publicClient: true
    standardFlowEnabled: true
    directAccessGrantsEnabled: true
    redirectUris: ["http://localhost:${FRONTEND_PORT}/*"]
    webOrigins: ["http://localhost:${FRONTEND_PORT}"]
    attributes:
      pkce.code.challenge.method: "S256"
      
  required_realm_settings:
    registrationAllowed: true
    loginWithEmailAllowed: true
    
  example_init_script: |
    #!/bin/bash
    # init-keycloak.sh - Complete client configuration
    
    KEYCLOAK_URL="${KEYCLOAK_URL:-http://localhost:8080}"
    REALM="${KEYCLOAK_REALM:-myrealm}"
    CLIENT_ID="${KEYCLOAK_CLIENT_ID:-myapp-frontend}"
    FRONTEND_URL="${FRONTEND_URL:-http://localhost:5173}"
    
    # Get admin token
    ADMIN_TOKEN=$(curl -s -X POST "$KEYCLOAK_URL/realms/master/protocol/openid-connect/token" \
      -d "username=admin&password=${KEYCLOAK_ADMIN_PASSWORD:-admin}&grant_type=password&client_id=admin-cli" \
      | jq -r '.access_token')
    
    # Create realm if not exists
    curl -s -X POST "$KEYCLOAK_URL/admin/realms" \
      -H "Authorization: Bearer $ADMIN_TOKEN" \
      -H "Content-Type: application/json" \
      -d "{\"realm\": \"$REALM\", \"enabled\": true, \"registrationAllowed\": true, \"loginWithEmailAllowed\": true}"
    
    # Create/update client with COMPLETE config
    curl -s -X POST "$KEYCLOAK_URL/admin/realms/$REALM/clients" \
      -H "Authorization: Bearer $ADMIN_TOKEN" \
      -H "Content-Type: application/json" \
      -d "{
        \"clientId\": \"$CLIENT_ID\",
        \"enabled\": true,
        \"publicClient\": true,
        \"standardFlowEnabled\": true,
        \"directAccessGrantsEnabled\": true,
        \"redirectUris\": [\"$FRONTEND_URL/*\"],
        \"webOrigins\": [\"$FRONTEND_URL\"],
        \"attributes\": {\"pkce.code.challenge.method\": \"S256\"}
      }"
    
    echo "✓ Keycloak initialized: $REALM realm, $CLIENT_ID client"

# =============================================================================
# MULTI-CLIENT AUDIENCE CONFIGURATION (V20 BUG FIX)
# =============================================================================
multi_client_audience:
  description: |
    When frontend and backend use different Keycloak clients, the backend
    validates JWT tokens against its client_id in the audience claim.
    Frontend tokens don't include backend client_id by default → 401 errors.
    
    Discovered in: V20 ResuMax experiment (December 2025)
    
  symptom: |
    - User logs in successfully via Keycloak
    - All API calls return 401 Unauthorized
    - Backend logs show "Invalid audience" error
    
  cause: |
    Frontend gets token with audience: ["resumax-frontend"]
    Backend validates token expecting audience: "resumax-backend"
    Token doesn't contain "resumax-backend" → validation fails
    
  solution: |
    Add an audience mapper to the frontend client that includes the backend
    client in the token's audience claim.
    
  implementation:
    via_admin_console:
      steps:
        - Go to Keycloak Admin Console → Clients → [frontend-client]
        - Click "Client scopes" tab
        - Click "[client]-dedicated" scope
        - Click "Add mapper" → "By configuration"
        - Select "Audience"
        - Configure:
            - Name: "backend-audience"
            - Included Client Audience: "[backend-client-id]"
            - Add to ID token: OFF
            - Add to access token: ON
        - Save
        
    via_api_script: |
      # Add to init-keycloak.sh or fix-keycloak.sh:
      
      echo "Adding audience mapper for backend..."
      PROTOCOL_MAPPER=$(cat <<EOF
      {
        "name": "${BACKEND_CLIENT_ID}-audience",
        "protocol": "openid-connect",
        "protocolMapper": "oidc-audience-mapper",
        "consentRequired": false,
        "config": {
          "included.client.audience": "${BACKEND_CLIENT_ID}",
          "id.token.claim": "false",
          "access.token.claim": "true"
        }
      }
      EOF
      )
      
      # Get frontend client UUID
      CLIENT_UUID=$(curl -s "$KEYCLOAK_URL/admin/realms/$REALM/clients?clientId=$FRONTEND_CLIENT_ID" \
        -H "Authorization: Bearer $ADMIN_TOKEN" | jq -r '.[0].id')
      
      # Add mapper to frontend client
      curl -s -X POST \
        "$KEYCLOAK_URL/admin/realms/$REALM/clients/${CLIENT_UUID}/protocol-mappers/models" \
        -H "Authorization: Bearer $ADMIN_TOKEN" \
        -H "Content-Type: application/json" \
        -d "${PROTOCOL_MAPPER}"
      
      echo "✓ Audience mapper added"
      echo "  Note: Users must log out and log back in to get new token"
      
  after_applying: |
    Users must log out and log back in to get a new token with the updated
    audience claim. Existing tokens will still fail validation until refreshed.
    
  alternative_solutions:
    disable_audience_check:
      description: Less secure but simpler
      code: |
        # In backend JWT validation:
        jwt.decode(
            token,
            key,
            algorithms=["RS256"],
            options={
                "verify_signature": True,
                "verify_aud": False,  # Disable audience check
                "verify_exp": True,
            }
        )
      warning: Only use in dev/testing environments
      
    use_same_client:
      description: Use single client for both frontend and backend
      tradeoff: Less separation of concerns, same token scopes

# =============================================================================
# SECURITY CHECKLIST
# =============================================================================
security:
  production_checklist:
    - "[ ] HTTPS enabled (KC_HOSTNAME_STRICT=true)"
    - "[ ] Admin password changed from default"
    - "[ ] Public client disabled for confidential apps"
    - "[ ] Redirect URIs restricted to production domains"
    - "[ ] Brute force protection enabled"
    - "[ ] Audit logging enabled"

# =============================================================================
# IMPLEMENTATION INSTRUCTIONS
# =============================================================================
implementation_instructions: |
  ## For AI Implementation Agents
  
  1. **Add to docker-compose** using the compose_snippet
  2. **Create realm JSON** based on template
  3. **Configure frontend** with keycloak-js or next-auth
  4. **Add JWT validation** to backend API
  5. **Test login flow** end-to-end
  
  ### Quick Start:
  ```bash
  # Access admin console
  open http://localhost:8080/admin
  # Login: admin / (your KEYCLOAK_ADMIN_PASSWORD)
  
  # Get OIDC config for your realm
  curl http://localhost:8080/realms/my-realm/.well-known/openid-configuration
  ```
