# =============================================================================
# FastAPI Base Component
# =============================================================================
# Production-ready Python backend scaffold WITHOUT LLM dependencies.
# Use this as the foundation for any Python API backend.
# =============================================================================

name: fastapi-base
version: 1.0.0
category: backend
validated: 2024-12-28

description: |
  Pure FastAPI backend scaffold - no LLM or AI dependencies.
  Includes async database support, Docker setup, health checks,
  and production-ready patterns.
  
  Use this for:
  - General REST APIs
  - CRUD applications
  - Microservices
  - API backends that DON'T need LLM (or will add separately)

# =============================================================================
# PORTS & NETWORKING
# =============================================================================
ports:
  default: 8000
  configurable: true
  health_check: /health
  api_docs: /docs

# =============================================================================
# ENVIRONMENT VARIABLES
# =============================================================================
environment:
  required:
    - name: DATABASE_URL
      description: PostgreSQL connection string
      format: postgresql+asyncpg://user:pass@host:5432/dbname
      docker_format: postgresql+asyncpg://user:pass@postgres:5432/dbname
      
  optional:
    - name: ALLOWED_ORIGINS
      description: CORS allowed origins (comma-separated)
      default: "*"
      production: "https://yourdomain.com"
      
    - name: DEBUG
      description: Enable debug mode
      default: "false"
      
    - name: SECRET_KEY
      description: Secret key for signing (JWT, etc.)
      sensitive: true
      
    - name: PORT
      description: Server port
      default: "8000"

# =============================================================================
# DEPENDENCIES
# =============================================================================
dependencies:
  python:
    core:
      - fastapi>=0.100.0
      - uvicorn[standard]>=0.22.0
      - pydantic>=2.0.0
      - pydantic-settings>=2.0.0
      - python-dotenv>=1.0.0
    
    database:
      - sqlalchemy>=2.0.0
      - asyncpg>=0.28.0
      - alembic>=1.12.0
    
    utilities:
      - python-multipart>=0.0.6  # For file uploads
      - httpx>=0.24.0            # For HTTP client

# =============================================================================
# DOCKER
# =============================================================================
docker:
  image: catalog/fastapi-base
  base: python:3.12-slim
  port: 8000
  
  dockerfile: |
    FROM python:3.12-slim
    WORKDIR /app
    
    # Install system dependencies
    RUN apt-get update && apt-get install -y \
        curl \
        postgresql-client \
        && rm -rf /var/lib/apt/lists/*
    
    # Install Python dependencies
    COPY requirements.txt .
    RUN pip install --no-cache-dir -r requirements.txt
    
    # Copy application
    COPY . .
    
    EXPOSE 8000
    CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000"]
  
  health_check:
    test: ["CMD", "curl", "-f", "http://localhost:8000/health"]
    interval: 30s
    timeout: 10s
    retries: 3
    start_period: 10s

  docker_compose_snippet: |
    backend:
      build:
        context: ./backend
        dockerfile: Dockerfile
      ports:
        - "8000:8000"
      environment:
        DATABASE_URL: postgresql+asyncpg://user:pass@postgres:5432/dbname
        ALLOWED_ORIGINS: "http://localhost:5173,http://localhost:3000"
        DEBUG: "true"
      depends_on:
        postgres:
          condition: service_healthy
      healthcheck:
        test: ["CMD", "curl", "-f", "http://localhost:8000/health"]
        interval: 30s
        timeout: 10s
        retries: 3

# =============================================================================
# FILE STRUCTURE
# =============================================================================
files:
  structure: |
    backend/
    ├── app/
    │   ├── __init__.py
    │   ├── main.py           # FastAPI app entry point
    │   ├── config.py         # Settings management
    │   ├── database.py       # Async SQLAlchemy setup
    │   ├── models/           # SQLAlchemy models
    │   │   └── __init__.py
    │   ├── schemas/          # Pydantic schemas
    │   │   └── __init__.py
    │   ├── routes/           # API route handlers
    │   │   └── __init__.py
    │   └── services/         # Business logic
    │       └── __init__.py
    ├── alembic/              # Database migrations
    ├── requirements.txt
    ├── Dockerfile
    └── .dockerignore

# =============================================================================
# TEMPLATE CODE
# =============================================================================
templates:

  main_py: |
    """FastAPI Application Entry Point."""
    
    from contextlib import asynccontextmanager
    from fastapi import FastAPI
    from fastapi.middleware.cors import CORSMiddleware
    
    from app.config import settings
    from app.database import create_tables
    from app.routes import router
    
    
    @asynccontextmanager
    async def lifespan(app: FastAPI):
        """Application lifespan - startup and shutdown."""
        # Startup
        await create_tables()
        yield
        # Shutdown (cleanup if needed)
    
    
    app = FastAPI(
        title=settings.app_name,
        version="1.0.0",
        lifespan=lifespan
    )
    
    # CORS Configuration
    origins = settings.allowed_origins.split(",") if settings.allowed_origins else ["*"]
    app.add_middleware(
        CORSMiddleware,
        allow_origins=["*"] if "*" in origins else origins,
        allow_credentials="*" not in origins,  # Cannot use credentials with "*"
        allow_methods=["*"],
        allow_headers=["*"],
    )
    
    # Include routes
    app.include_router(router, prefix="/api")
    
    
    @app.get("/health")
    async def health_check():
        """Health check endpoint for container orchestration."""
        return {"status": "healthy", "service": settings.app_name}

  config_py: |
    """Application configuration using pydantic-settings."""
    
    from pydantic_settings import BaseSettings
    from functools import lru_cache
    
    
    class Settings(BaseSettings):
        """Application settings loaded from environment."""
        
        app_name: str = "FastAPI Service"
        debug: bool = False
        
        # Database
        database_url: str
        
        # CORS
        allowed_origins: str = "*"
        
        # Security
        secret_key: str = "change-me-in-production"
        
        class Config:
            env_file = ".env"
            env_file_encoding = "utf-8"
    
    
    @lru_cache()
    def get_settings() -> Settings:
        return Settings()
    
    
    settings = get_settings()

  database_py: |
    """Async SQLAlchemy database setup."""
    
    from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession, async_sessionmaker
    from sqlalchemy.orm import DeclarativeBase
    
    from app.config import settings
    
    
    engine = create_async_engine(
        settings.database_url,
        echo=settings.debug,
        pool_pre_ping=True
    )
    
    async_session_maker = async_sessionmaker(
        engine,
        class_=AsyncSession,
        expire_on_commit=False
    )
    
    
    class Base(DeclarativeBase):
        """Base class for SQLAlchemy models."""
        pass
    
    
    async def create_tables():
        """Create database tables."""
        async with engine.begin() as conn:
            await conn.run_sync(Base.metadata.create_all)
    
    
    async def get_db():
        """Dependency for getting database session."""
        async with async_session_maker() as session:
            try:
                yield session
            finally:
                await session.close()

  routes_init_py: |
    """API Routes."""
    
    from fastapi import APIRouter
    
    router = APIRouter()
    
    
    @router.get("/")
    async def root():
        return {"message": "API is running"}
    
    
    # Add more routers here:
    # from app.routes import users, items
    # router.include_router(users.router, prefix="/users", tags=["users"])
    # router.include_router(items.router, prefix="/items", tags=["items"])

  requirements_txt: |
    fastapi>=0.100.0
    uvicorn[standard]>=0.22.0
    pydantic>=2.0.0
    pydantic-settings>=2.0.0
    python-dotenv>=1.0.0
    sqlalchemy>=2.0.0
    asyncpg>=0.28.0
    alembic>=1.12.0
    python-multipart>=0.0.6
    httpx>=0.24.0

  dockerignore: |
    __pycache__
    *.pyc
    *.pyo
    .env
    .git
    .gitignore
    .venv
    venv
    *.md
    .pytest_cache
    .mypy_cache

# =============================================================================
# PATTERNS
# =============================================================================
patterns:

  crud_route: |
    """Example CRUD route pattern."""
    
    from fastapi import APIRouter, Depends, HTTPException
    from sqlalchemy import select
    from sqlalchemy.ext.asyncio import AsyncSession
    
    from app.database import get_db
    from app.models.item import Item
    from app.schemas.item import ItemCreate, ItemRead
    
    router = APIRouter()
    
    
    @router.get("/", response_model=list[ItemRead])
    async def list_items(db: AsyncSession = Depends(get_db)):
        result = await db.execute(select(Item))
        return result.scalars().all()
    
    
    @router.post("/", response_model=ItemRead)
    async def create_item(item: ItemCreate, db: AsyncSession = Depends(get_db)):
        db_item = Item(**item.model_dump())
        db.add(db_item)
        await db.commit()
        await db.refresh(db_item)
        return db_item
    
    
    @router.get("/{item_id}", response_model=ItemRead)
    async def get_item(item_id: int, db: AsyncSession = Depends(get_db)):
        result = await db.execute(select(Item).where(Item.id == item_id))
        item = result.scalar_one_or_none()
        if not item:
            raise HTTPException(404, "Item not found")
        return item

  model_example: |
    """Example SQLAlchemy model."""
    
    from datetime import datetime
    from sqlalchemy import String, DateTime, func
    from sqlalchemy.orm import Mapped, mapped_column
    
    from app.database import Base
    
    
    class Item(Base):
        __tablename__ = "items"
        
        id: Mapped[int] = mapped_column(primary_key=True)
        name: Mapped[str] = mapped_column(String(255))
        description: Mapped[str | None] = mapped_column(String(1000))
        created_at: Mapped[datetime] = mapped_column(
            DateTime, server_default=func.now()
        )
        updated_at: Mapped[datetime] = mapped_column(
            DateTime, server_default=func.now(), onupdate=func.now()
        )

  schema_example: |
    """Example Pydantic schemas."""
    
    from datetime import datetime
    from pydantic import BaseModel
    
    
    class ItemBase(BaseModel):
        name: str
        description: str | None = None
    
    
    class ItemCreate(ItemBase):
        pass
    
    
    class ItemRead(ItemBase):
        id: int
        created_at: datetime
        updated_at: datetime
        
        class Config:
            from_attributes = True

# =============================================================================
# CORS CONFIGURATION
# =============================================================================
cors:
  development:
    allow_origins: ["*"]
    allow_credentials: false
    note: |
      Use "*" for local development.
      Cannot use credentials=True with wildcard origin.
      
  production:
    allow_origins: "${ALLOWED_ORIGINS}"
    allow_credentials: true
    note: |
      Specify exact origins: "https://app.example.com,https://www.example.com"
      Can enable credentials for cookies/auth headers.

# =============================================================================
# GOTCHAS
# =============================================================================
gotchas:

  sync_vs_async_sqlalchemy:
    problem: "Using sync SQLAlchemy operations in async routes"
    cause: "SQLAlchemy sync operations block the event loop"
    solution: |
      Always use async SQLAlchemy patterns:
      - create_async_engine instead of create_engine
      - AsyncSession instead of Session
      - await db.execute() instead of db.query()

  cors_credentials_with_wildcard:
    problem: "CORS error when frontend sends credentials"
    cause: "Cannot use credentials=True with allow_origins=['*']"
    solution: |
      Either:
      1. Set specific origins and allow_credentials=True
      2. Use wildcard origin and allow_credentials=False

  database_url_format:
    problem: "Database connection fails"
    cause: "Wrong URL format for async SQLAlchemy"
    solution: |
      Use asyncpg driver in URL:
      - Wrong: postgresql://user:pass@host:5432/db
      - Right: postgresql+asyncpg://user:pass@host:5432/db

  docker_database_url:
    problem: "Backend can't connect to database in Docker"
    cause: "Using localhost instead of Docker service name"
    solution: |
      In docker-compose, use service name:
      - Wrong: postgresql+asyncpg://user:pass@localhost:5432/db
      - Right: postgresql+asyncpg://user:pass@postgres:5432/db

# =============================================================================
# USAGE
# =============================================================================
usage:
  local_development: |
    # Create virtual environment
    python -m venv venv
    source venv/bin/activate
    
    # Install dependencies
    pip install -r requirements.txt
    
    # Run with auto-reload
    uvicorn app.main:app --reload --port 8000
  
  docker: |
    # Build and run
    docker build -t my-api ./backend
    docker run -p 8000:8000 -e DATABASE_URL=... my-api
  
  docker_compose: |
    # Start all services
    docker-compose up -d
    
    # View logs
    docker-compose logs -f backend

---
# Metadata
last_updated: "2025-12-28"
llm_dependencies: none
composable_with:
  - llm/api-direct/structured-output  # For AI features
  - auth/keycloak                      # For authentication
  - database/postgres                  # For database
